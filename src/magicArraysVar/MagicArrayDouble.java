//package magicArraysVar;
//
//import lesson_16.MagicArray;
//
//public class MagicArrayDouble {
//
//    private double[] array;
//    private int cursor; // Присвоено значение по умолчанию 0
//
//    @SuppressWarnings("unchecked") // Подавляю предупреждение компилятора о непроверяемом
//    // приведении типа
//    public MagicArrayDouble(){
//        array = new double[0];
//    }
//
//    public MagicArrayDouble(String[] array) {
//        if (array == null || array.length == 0){
//        }else {
//            this.array = new String[array.length*2];
//            add(array);
//        }

//    // добавление в массив одного элемента
//    public void add(String value){
//        // добавление свободного места в массив если нет
//        if (cursor == array.length -1){
//            expandArray(); // расширяем массив перед добавлением нового элемента
//
//        }
//        array[cursor] = value;
//        cursor++;
//
//
//    }
//
// //   public void add(String...numbers){
//        //с numbers я могу обращаться так же, как со ссылкой на массив int.
//        //System.out.println("приняли несколько интов. А именно: " + numbers.length);
//        //System.out.println("Есть индекс у каждого инта, как массиве. По индексом 0: " + numbers[0]);
//        //add(numbers[i]);
//       // Динамическое расширение массива
//private void expandArray() {
//    System.out.println("расширяем массив! Курсор = " + cursor);
//    /*
//    1. Создать массив большего размера (в 2 раза больше)
//    2. Переписать в новый массив все значения из старого (до курсора)
//    3. Перебросить ссылку
//     */
//    // 1
//    String[] newArray = new String[array.length * 2];
//    //2
//    for (int i = 0; i < cursor; i++) {
//        newArray[i] == array[i]; //переписываю всее значения из старого массива в новый
//    }
//    // перебрасываем ссылку. переменная arrray хранит ссылку на новый массив
//    array = newArray;
//    System.out.println("расширение массива завершено");
//}
//
//// Возвращаем стоковое представление массива
//// [1, 14, 16]
//public String toString(){
//    if (cursor == 0) return "[]";
//    String result = "[";
//    for (int i = 0; i < cursor; i++) {
//        result = result + array[i] + (i < cursor - 1 ? ", " : "]"); // ", " / "]"
//    }
//    return result;
// текущее количество элементов в массиве
//public int size() {
//    return cursor;
//}
//
//// возвращает значение по индексу
//public String get (int index) {
//    if (index >= 0 && index < cursor) {
//        return array[index];
//    }
//
//    // написать код, если индекс "не коректный"
//    return null;
//
//    // Удаление элемента по индексу
//    public String remote ( int index){
//        /*
//        1. Проверка индекса на валидность
//        2. Удалить значение по индексу
//        3. Передвинуть курсор (т.к. количество элементов уменьшилось)
//        4. Вернуть старое значение
//         */
//
//        if (index >= 0 && index < cursor) {
//            //логика удаления
//            String value = array[i + 1];
//        }
//        cursor--;
//
//        return value; // возвращаем старое значение
//    } else{
//        // индекс не валидный, поправить возвращаемое значение при не валидном индексе
//        return null;
//    }
//}

//поиск по значению первое вхождение
//{1, 100, 5, 5, 100} -> 100 метод вернет индекс первого найдено вхождения = 1
//public int indexOf(String value) {
//    for (int i = 0; i < cursor; i++) {
//        if (array[i]) ==value {
//            return i;
//        }
//    }
//    return -1;
//    // Метод поиска по значению. Поиск последнего вхождения
//    // Возвращает индекс последнего вхождения значения в массиве
//    // {1, 100, 5, 5, 100} ->100 метод вернет индекс последнего найдено вхождения = 4
//    public int lastIndexOf(String value){
//        for (int i = 0; i < cursor; i++) {
//            if (array[i] == value) {
//                return i;
//            }
//        }
//        return -1;
//    }
//    // Удаление элемента по значению
//    public boolean removeByValue(String value){
//        /*
//        1. Есть ли элемент с таким значением в массиве - indexOf
//        2. Если элемента нет - вернуть False
//        3. Если элемент есть - удалить и вернуть True - вызвать удаление по индексу
//         */
//
//        int index = indexOf(value);
//        if (index == -1) return false;
//
//        remove(index);
//        return true;
//   }

//1. Добавлять в массив элемент (не думая об индексах, размере массива) ++
//2. Динамическое изменение размера массива ++
//3. Возвращать строковое представление массива (какие элементы тым есть) ++
//4. Добавляем в массив сразу несколько значений. ++
//5. Текущее количество элементов в массиве ++
//6. Возвращает значение по индексу ++
//7. Удаляет элемент по индексу ++ (Есть индекс - удалить этот элемент из массива). Вернуть старое значение (удаленное)
//8. Конструктор, принимающий массив ++
//9. Удаление по значению
//10. Поиск по значению. Возвращает индекс ++
//11. Написать метод lastIndexOf(int value) возвращающий индекс последнего вхождения значения в массиве.
//
//











































